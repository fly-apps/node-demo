<% for (const [name, pkg] of Object.entries(imports)) { -%>
<% if (options.typescript && !options.esm && !name.includes('{')) { -%>
import * as <%= name %> from '<%= pkg %>';
<% } else if (options.typescript || options.esm) { -%>
import <%= name %> from '<%= pkg %>';
<% } else { -%>
const <%= name %> = require('<%= pkg %>');
<% } -%>
<% } -%>

<% if (options.express) { -%>
<% if (options.ws) { -%>
// set up express and web socket
const { app, getWss } = expressWs(express());
const wss = getWss();
<% } else { -%>
// set up express web server
const app = express();
<% } -%>

// set up static content<% if (options.ejs) { %> and ejs views<% } %>
app.use(express.static('public'));
<% if (options.ejs) { -%>
app.set('view engine', 'ejs');
<% } -%>
<% } else { -%>
// set up web server
const server = http.createServer(listener);
<% if (options.ws) { -%>
const wss = new WebSocketServer({ noServer: true });
<% } -%>
<% } -%>

<%- include('_restart.ejs') -%>

// last known count
let count = 0;

<% if (options.express) { -%>
// Main page
app.get('/', async (_request, response) => {
<% } else { -%>
// Map of file extensions to mime types
const mimeTypes<% if (options.typescript) { %> : Record<string, string><% } %> = {
  "ico": "image/x-icon",
  "js": "text/javascript",
  "css": "text/css",
  "svg": "image/svg+xml"
};

// Process requests based on pathname
async function listener(request<% if (options.typescript) { %> : http.IncomingMessage<% } %>, response<% if (options.typescript) { %> : http.ServerResponse<% } %>) {
  const { pathname } = url.parse(request.url<% if (options.typescript) { %> as string<% } %>);
  
  if (pathname === '/') {
    await main(request, response)
  } else if (<% if (options.typescript) { %>pathname && <% } %>fs.existsSync(`public${pathname}`)) {
    try {
      let contents = fs.readFileSync(`public${pathname}`)
      let mimeType = mimeTypes[pathname.split('.').pop()<% if (options.typescript) { %> as string<% } %>] || 'application/octet-stream'
      
      response.writeHead(200, { "Content-Type": mimeType });
      response.write(contents, "binary");
    } catch (error) {
      response.writeHead(500, {"Content-Type": "text/plain"});
      response.write(error + "\n");
    }
    response.end();
  } else {
    response.writeHead(400);
    response.end("Not found.");
  }
}

// Main page
async function main(_request<% if (options.typescript) { %> : http.IncomingMessage<% } %>, response<% if (options.typescript) { %> : http.ServerResponse<% } %>) {
<% } -%>
  let oldCount = count;

  if (postgres.client) {
    // get current count (may return zero rows)
    let result = await postgres.client.query('SELECT "count" from "welcome"');

    // increment count, creating table row if necessary
    if (!result.rows.length) {
      count = 1;
      await postgres.client?.query('INSERT INTO "welcome" VALUES($1)', [count]);
    } else {
      count = result.rows[0].count + 1;
      await postgres.client?.query('UPDATE "welcome" SET "count" = $1', [count]);
    }
  }

<% if (options.ws) { -%>
  if (oldCount !== count) {
<% if (options.redis) { -%>
    // publish new count on redis
    publisher.client?.publish('welcome:counter', count.toString());
<% } else { -%>
    // publish new count to all websocket clients
    wss.clients.forEach(client => {
      try { client.send(count.toString()) } catch {};
    });
<% } -%>
  }

<% } -%>
  // render HTML response
<% if (options.express) { -%>
<% if (options.ejs) { -%>
  response.render('index', { count });
<% } else { -%>
  try {
    let content = fs.readFileSync('views/index.ejs', 'utf-8')
      .replace('<%%= count %>', count.toString());
    response.set('Content-Type', 'text/html');
    response.send(content)
  } catch(error) {
    response.send()
  }
<% } -%>
<% } else { -%>
  try {
    let contents = fs.readFileSync(`views/index.ejs`, 'utf-8');
<% if (options.ejs) { -%>
    contents = ejs.render(contents, { count });
<% } else { -%>
    contents = contents.replace('<%%= count %>', count.toString());
<% } -%>

    response.writeHead(200, { "Content-Type": "text/html" });
    response.write(contents, "utf-8");
  } catch (error) {
    response.writeHead(500, {"Content-Type": "text/plain"});
    response.write(error + "\n");
  }

  response.end();
<% } -%>
}<% if (options.express) { %>)<% } %>;
<% if (options.ws) { -%>

// Define web socket route
<% if (options.express) { -%>
app.ws('/websocket', (ws) => {
<% } else { -%>
server.on('upgrade', (request, socket, head) => {
  const { pathname } = url.parse(request.url<% if (options.typescript) { %> as string<% } %>);

  if (pathname === '/websocket') {
    wss.handleUpgrade(request, socket, head, (ws) => {
      wss.emit('connection', ws, request);
    });
  } else {
    socket.destroy();
  }
});

wss.on('connection', (ws) => {
<% } -%>
  // update client on a best effort basis
  try { ws.send(count.toString()) } catch {};

  // We donâ€™t expect any messages on websocket, but log any ones we do get.
  ws.on('message', console.log);
});
<% } -%>

(async () => {
<% if (options.redis) { -%>
  // try to connect to each service
  await Promise.all([
    subscriber.tryConnect(true),
    publisher.tryConnect(true),
    postgres.tryConnect(true)
  ]);
<% } else { -%>
  // try to connect to postgres
  await postgres.tryConnect(true);
<% } -%>
  
  // Ensure welcome table exists
  await postgres.client?.query('CREATE TABLE IF NOT EXISTS "welcome" ( "count" INTEGER )');

  // Start web server on port 3000
  <% if (options.express) { %>app<% } else { %>server<% } %>.listen(3000, () => {
    console.log('Server is listening on port 3000');
  });
})();
