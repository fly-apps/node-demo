<% for (const [name, pkg] of Object.entries(imports)) { -%>
<% if (options.typescript && !options.esm && !name.includes('{')) { -%>
import * as <%= name %> from '<%= pkg %>';
<% } else if (options.typescript || options.esm) { -%>
import <%= name %> from '<%= pkg %>';
<% } else { -%>
const <%= name %> = require('<%= pkg %>');
<% } -%>
<% } -%>

<% if (options.express) { -%>
<% if (options.ws) { -%>
// set up express and web socket
const { app, getWss } = expressWs(express());
const wss = getWss();
<% } else { -%>
// set up express web server
const app = express();
<% } -%>

// set up static content<% if (options.ejs) { %> and ejs views<% } %>
app.use(express.static('public'));
<% if (options.ejs) { -%>
app.set('view engine', 'ejs');
<% } -%>
<% } else { -%>
// set up web server
const server = http.createServer(listener);
<% if (options.ws) { -%>
const wss = new WebSocketServer({ noServer: true });
<% } -%>
<% } -%>

<% if (options.redis || (options.postgres && !orm)) { -%>
<%- include('_restart.ejs', { options, orm }) -%>

<% } -%>
<% if (options.prisma) { -%>
// open database
const prisma = new PrismaClient();

<% } else if (options.sqlite3) { -%>
// open database
const db = new sqlite3.Database('counter.sqlite3');

<% } -%>
// last known count
let count = 0;

<% if (options.express) { -%>
// Main page
app.get('/', async (_request, response) => {
<% } else { -%>
// Map of file extensions to mime types
const mimeTypes<% if (options.typescript) { %> : Record<string, string><% } %> = {
  "ico": "image/x-icon",
  "js": "text/javascript",
  "css": "text/css",
  "svg": "image/svg+xml"
};

// Process requests based on pathname
async function listener(request<% if (options.typescript) { %> : http.IncomingMessage<% } %>, response<% if (options.typescript) { %> : http.ServerResponse<% } %>) {
  const { pathname } = url.parse(request.url<% if (options.typescript) { %> as string<% } %>);
  
  if (pathname === '/') {
    await main(request, response)
  } else if (<% if (options.typescript) { %>pathname && <% } %>fs.existsSync(`public${pathname}`)) {
    try {
      let contents = fs.readFileSync(`public${pathname}`)
      let mimeType = mimeTypes[pathname.split('.').pop()<% if (options.typescript) { %> as string<% } %>] || 'application/octet-stream'
      
      response.writeHead(200, { "Content-Type": mimeType });
      response.write(contents, "binary");
    } catch (error) {
      response.writeHead(500, {"Content-Type": "text/plain"});
      response.write(error + "\n");
    }
    response.end();
  } else {
    response.writeHead(400);
    response.end("Not found.");
  }
}

// Main page
async function main(_request<% if (options.typescript) { %> : http.IncomingMessage<% } %>, response<% if (options.typescript) { %> : http.ServerResponse<% } %>) {
<% } -%>
<% if (options.ws) { -%>
  let oldCount = count;

<% } -%>
<%- include('_update.ejs', { options }) -%>

<% if (options.ws) { -%>
  if (oldCount !== count) {
<% if (options.redis) { -%>
    // publish new count on redis
    publisher.client?.publish('welcome:counter', count.toString());
<% } else { -%>
    // publish new count to all websocket clients
    wss.clients.forEach(client => {
      try { client.send(count.toString()) } catch {};
    });
<% } -%>
  }

<% } -%>
  // render HTML response
<% if (options.express) { -%>
<% if (options.ejs) { -%>
  response.render('index', { count });
<% } else { -%>
  try {
    let content = fs.readFileSync('views/index.ejs', 'utf-8')
      .replace('<%= count %>', count.toString());
    response.set('Content-Type', 'text/html');
    response.send(content)
  } catch(error) {
    response.send()
  }
<% } -%>
<% } else { -%>
  try {
    let contents = fs.readFileSync(`views/index.<% if (options.ejs) { %>ejs<% } else { %>tmpl<% } %>`, 'utf-8');
<% if (options.ejs) { -%>
    contents = ejs.render(contents, { count });
<% } else { -%>
    contents = contents.replace('<%= count %>', count.toString());
<% } -%>

    response.writeHead(200, { "Content-Type": "text/html" });
    response.write(contents, "utf-8");
  } catch (error) {
    response.writeHead(500, {"Content-Type": "text/plain"});
    response.write(error + "\n");
  }

  response.end();
<% } -%>
}<% if (options.express) { %>)<% } %>;
<% if (options.ws) { -%>

// Define web socket route
<% if (options.express) { -%>
app.ws('/websocket', (ws) => {
<% } else { -%>
server.on('upgrade', (request, socket, head) => {
  const { pathname } = url.parse(request.url<% if (options.typescript) { %> as string<% } %>);

  if (pathname === '/websocket') {
    wss.handleUpgrade(request, socket, head, (ws) => {
      wss.emit('connection', ws, request);
    });
  } else {
    socket.destroy();
  }
});

wss.on('connection', (ws) => {
<% } -%>
  // update client on a best effort basis
  try { ws.send(count.toString()) } catch {};

  // We donâ€™t expect any messages on websocket, but log any ones we do get.
  ws.on('message', console.log);
});
<% } -%>

<%- include('_startup.ejs', { options, orm }) -%>
