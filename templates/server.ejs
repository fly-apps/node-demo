<% for (const [name, pkg] of Object.entries(imports)) { -%>
<% if (options.typescript && !options.esm && !name.includes('{')) { -%>
import * as <%= name %> from '<%= pkg %>';
<% } else if (options.typescript || options.esm) { -%>
import <%= name %> from '<%= pkg %>';
<% } else { -%>
const <%= name %> = require('<%= pkg %>');
<% } -%>
<% } -%>

<% if (options.express) { -%>
// set up express and web socket
const { app, getWss } = expressWs(express());
const wss = getWss();

// set up static content<% if (options.ejs) { %> and ejs views<% } %>
app.use(express.static('public'));
<% if (options.ejs) { -%>
app.set('view engine', 'ejs');
<% } -%>
<% } else { -%>
// set up web server
const server = http.createServer(listener);
const wss = new WebSocketServer({ noServer: true });
<% } -%>

<% if (options.redis) { -%>
// common reconnect logic for postgres, redis clients
const reconnect = {
  client: null<% if (options.typescript) { %> as any<% } %>,
<% } else { -%>
// postgres client
const postgres = {
<% } -%>
  interval: null<% if (options.typescript) { %> as NodeJS.Timer | null<% } %>,
<% if (options.typescript && options.redis) { -%>
  connect: null as Function | null,
  disconnect: null as Function | null,
<% } -%>

  reconnect() {
    if (this.interval) return;

    this.interval = setInterval(() => {
      this.tryConnect().catch(console.log)
    }, 1000);
  },

  async tryConnect(reconnect = false) {
    if (this.client || !this.connect || !this.disconnect) return;

    try {
      await this.connect();

      if (this.interval) {
        clearInterval(this.interval);
        this.interval = null;
      }
    } catch (error) {
      console.error(error);
      this.disconnect();
      if (reconnect) this.reconnect();
      throw(error);
    }
  }<% if (!options.redis) { -%>,

<% } else { %>
}


// redis subscriber
const subscriber = {
  ...reconnect,
<% if (options.typescript) { -%>
  client: null as redis.RedisClientType | null,
<% } -%>

  async connect() {
    this.client = redis.createClient({url: process.env.REDIS_URL});

    await this.client.connect();

    // Forward messages from redis to all websocket clients
    this.client.subscribe('welcome:counter', (message<% if (options.typescript) { %> : string<% } %>) => {
      count = parseInt(message);

      wss.clients.forEach(client => {
        try { client.send(message) } catch {};
      });
    }),

    this.client.on('error', (err<% if (options.typescript) { %>: object<% } %>) => {
      console.error('Redis Server Error', err);
      this.disconnect();
      this.reconnect();
    })
  },

  disconnect() {
    if (this.client) {
      this.client.quit();
      this.client = null;
    }
  }
};

// redis publisher
const publisher = {
  ...reconnect,
<% if (options.typescript) { -%>
  client: null as redis.RedisClientType | null,
<% } -%>

  async connect() {
    this.client = redis.createClient({url: process.env.REDIS_URL});

    await this.client.connect();
  },

  disconnect() {
    if (this.client) {
      this.client.quit();
      this.client = null;
    }
  }
}

// postgres client
const postgres = {
  ...reconnect,
<% } -%>
<% if (options.typescript) { -%>
  client: null as pg.Client | null,
<% } -%>

  async connect() {
    this.client = new pg.Client({connectionString: process.env.DATABASE_URL})

    await this.client.connect();
  },

  disconnect() {
    if (this.client) {
      this.client.end();
      this.client = null;
    }
  }
}

// last known count
let count = 0;

<% if (options.express) { -%>
// Main page
app.get('/', async (_request, response) => {
<% } else { -%>
// Map of file extensions to mime types
const mimeTypes<% if (options.typescript) { %> : Record<string, string><% } %> = {
  "js": "text/javascript",
  "css": "text/css"
};

// Process requests based on pathname
async function listener(request<% if (options.typescript) { %> : http.IncomingMessage<% } %>, response<% if (options.typescript) { %> : http.ServerResponse<% } %>) {
  const { pathname } = url.parse(request.url<% if (options.typescript) { %> as string<% } %>);
  
  if (pathname === '/') {
    await main(request, response)
  } else if (<% if (options.typescript) { %>pathname && <% } %>fs.existsSync(`public${pathname}`)) {
    try {
      let contents = fs.readFileSync(`public${pathname}`)
      let mimeType = mimeTypes[pathname.split('.').pop()<% if (options.typescript) { %> as string<% } %>] || 'application/octet-stream'
      
      response.writeHead(200, { "Content-Type": mimeType });
      response.write(contents, "binary");
    } catch (error) {
      response.writeHead(500, {"Content-Type": "text/plain"});
      response.write(error + "\n");
    }
    response.end();
  } else {
    response.writeHead(400);
    response.end("Not found.");
  }
}

// Main page
async function main(_request<% if (options.typescript) { %> : http.IncomingMessage<% } %>, response<% if (options.typescript) { %> : http.ServerResponse<% } %>) {
<% } -%>
  if (postgres.client) {
    // get current count (may return zero rows)
    let result = await postgres.client.query('SELECT "count" from "welcome"');

    // increment count, creating table row if necessary
    if (!result.rows.length) {
      count = 1;
      await postgres.client?.query('INSERT INTO "welcome" VALUES($1)', [count]);
    } else {
      count = result.rows[0].count + 1;
      await postgres.client?.query('UPDATE "welcome" SET "count" = $1', [count]);
    }
<% if (options.redis) { -%>

    // publish new count on redis
    publisher.client?.publish('welcome:counter', count.toString());
<% } else { -%>
    // publis new count to all websocket clients
    wss.clients.forEach(client => {
      try { client.send(count.toString()) } catch {};
    });
<% } -%>
  }

  // render HTML response
<% if (options.express) { -%>
<% if (options.ejs) { -%>
  response.render('index', { count });
<% } else { -%>
  try {
    let content = fs.readFileSync('views/index.ejs', 'utf-8')
      .replace('<%%= count %>', count.toString());
    response.set('Content-Type', 'text/html');
    response.send(content)
  } catch(error) {
    response.send()
  }
<% } -%>
<% } else { -%>
  try {
    let contents = fs.readFileSync(`views/index.ejs`, 'utf-8');
<% if (options.ejs) { -%>
    contents = ejs.render(contents, { count });
<% } else { -%>
    contents = contents.replace('<%%= count %>', count.toString());
<% } -%>

    response.writeHead(200, { "Content-Type": "text/html" });
    response.write(contents, "utf-8");
  } catch (error) {
    response.writeHead(500, {"Content-Type": "text/plain"});
    response.write(error + "\n");
  }

  response.end();
<% } -%>
}<% if (options.express) { %>)<% } %>;

// Define web socket route
<% if (options.express) { -%>
app.ws('/websocket', (ws) => {
<% } else { -%>
server.on('upgrade', (request, socket, head) => {
  const { pathname } = url.parse(request.url<% if (options.typescript) { %> as string<% } %>);

  if (pathname === '/websocket') {
    wss.handleUpgrade(request, socket, head, (ws) => {
      wss.emit('connection', ws, request);
    });
  } else {
    socket.destroy();
  }
});

wss.on('connection', (ws) => {
<% } -%>
  // update client on a best effort basis
  try { ws.send(count.toString()) } catch {};

  // We donâ€™t expect any messages on websocket, but log any ones we do get.
  ws.on('message', console.log);
});

(async () => {
<% if (options.redis) { -%>
  // try to connect to each service
  await Promise.all([
    subscriber.tryConnect(true),
    publisher.tryConnect(true),
    postgres.tryConnect(true)
  ]);
<% } else { -%>
  // try to connect to postgres
  await postgres.tryConnect(true);
<% } -%>
  
  // Ensure welcome table exists
  await postgres.client?.query('CREATE TABLE IF NOT EXISTS "welcome" ( "count" INTEGER )');

  // Start web server on port 3000
  <% if (options.express) { %>app<% } else { %>server<% } %>.listen(3000, () => {
    console.log('Server is listening on port 3000');
  });
})();
